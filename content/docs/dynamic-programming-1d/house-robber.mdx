---
title: House Robber
description: Find the maximum amount of money you can rob without alerting police
difficulty: Medium
tags: [dynamic-programming, array]
patterns: [dp-1d, decision-making]
timeComplexity: O(n)
spaceComplexity: O(1)
---

import { DifficultyBadge } from '@/components/mdx/DifficultyBadge';
import { TagList } from '@/components/mdx/TagList';
import { ComplexityTable } from '@/components/mdx/ComplexityTable';
import { HouseRobberVisualizer } from '@/components/visualizer/wrappers/HouseRobberVisualizer';

<div className="flex items-center gap-3 mb-6 flex-wrap">
  <DifficultyBadge difficulty="Medium" />
  <TagList tags={['dynamic-programming', 'array']} />
</div>

## Problem

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. The only constraint stopping you from robbing each of them is that **adjacent houses have security systems connected** and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight **without alerting the police**.

**Constraints:**
- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

**Examples:**

```
Input: nums = [1, 2, 3, 1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
```

```
Input: nums = [2, 7, 9, 3, 1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
Total amount you can rob = 2 + 9 + 1 = 12.
```

```
Input: nums = [5, 3, 4, 11, 2]
Output: 16
Explanation: Rob house 1 (money = 5) and rob house 4 (money = 11).
Total amount you can rob = 5 + 11 = 16.
```

## Visualization

<HouseRobberVisualizer houses={[2, 7, 9, 3, 1]} />

## Solutions

### Approach 1: Recursion (Brute Force)

Try all possible combinations: at each house, decide whether to rob it or skip it.

<ComplexityTable time="O(2^n)" space="O(n)" />

```typescript
function rob(nums: number[]): number {
  return robFrom(nums, 0);
}

function robFrom(nums: number[], index: number): number {
  // Base case: no more houses
  if (index >= nums.length) {
    return 0;
  }

  // Decision 1: Rob current house, skip next (can't rob adjacent)
  const robCurrent = nums[index] + robFrom(nums, index + 2);

  // Decision 2: Skip current house, try next
  const skipCurrent = robFrom(nums, index + 1);

  // Take maximum
  return Math.max(robCurrent, skipCurrent);
}
```

**Why This Is Slow:**
- Recalculates same subproblems many times
- For each house: 2 choices (rob or skip) → O(2^n) combinations
- Example: `robFrom(2)` computed multiple times from different paths

---

### Approach 2: Memoization (Top-Down DP)

Cache results to avoid recomputing subproblems.

<ComplexityTable time="O(n)" space="O(n)" />

```typescript
function rob(nums: number[]): number {
  const memo = new Map<number, number>();
  return robFrom(nums, 0, memo);
}

function robFrom(
  nums: number[],
  index: number,
  memo: Map<number, number>
): number {
  // Base case
  if (index >= nums.length) {
    return 0;
  }

  // Check cache
  if (memo.has(index)) {
    return memo.get(index)!;
  }

  // Rob current or skip current
  const robCurrent = nums[index] + robFrom(nums, index + 2, memo);
  const skipCurrent = robFrom(nums, index + 1, memo);

  const result = Math.max(robCurrent, skipCurrent);
  memo.set(index, result);

  return result;
}
```

**Key Improvements:**
- Each subproblem solved once and cached
- Time: O(n) - compute n values
- Space: O(n) - memo map + recursion stack

---

### Approach 3: Tabulation (Bottom-Up DP)

Build solution iteratively from base cases.

<ComplexityTable time="O(n)" space="O(n)" />

```typescript
function rob(nums: number[]): number {
  const n = nums.length;

  // Edge cases
  if (n === 0) return 0;
  if (n === 1) return nums[0];
  if (n === 2) return Math.max(nums[0], nums[1]);

  // DP array: dp[i] = max money robbing up to house i
  const dp: number[] = new Array(n);

  // Base cases
  dp[0] = nums[0];
  dp[1] = Math.max(nums[0], nums[1]);

  // Fill table
  for (let i = 2; i < n; i++) {
    // Option 1: Rob house i (add to dp[i-2])
    const robCurrent = nums[i] + dp[i - 2];

    // Option 2: Skip house i (take dp[i-1])
    const skipCurrent = dp[i - 1];

    // Take maximum
    dp[i] = Math.max(robCurrent, skipCurrent);
  }

  return dp[n - 1];
}
```

**Why This Works:**
- **dp[i]** = maximum money robbing houses 0 to i
- **Recurrence**: `dp[i] = max(nums[i] + dp[i-2], dp[i-1])`
  - Rob house i: can't rob i-1, so add to dp[i-2]
  - Skip house i: take best from dp[i-1]
- Build from bottom (house 0) to top (house n-1)

---

### Approach 4: Space-Optimized DP ⭐ (Optimal)

Only need last two values, not entire array.

<ComplexityTable time="O(n)" space="O(1)" />

```typescript
function rob(nums: number[]): number {
  const n = nums.length;

  // Edge cases
  if (n === 0) return 0;
  if (n === 1) return nums[0];

  // Track last two values
  let prev2 = nums[0];  // dp[i-2]
  let prev1 = Math.max(nums[0], nums[1]);  // dp[i-1]

  for (let i = 2; i < n; i++) {
    const current = Math.max(nums[i] + prev2, prev1);

    // Slide window forward
    prev2 = prev1;
    prev1 = current;
  }

  return prev1;
}
```

**Why This Is Optimal:**
1. **O(n) Time**: Single pass through houses
2. **O(1) Space**: Only 2 variables (prev2, prev1)
3. **Same Logic**: Still computing max(rob, skip)
4. **Sliding Window**: Keep only what we need

**This is the preferred interview solution!**

---

## Tricks & Key Insights

### Pattern Recognition

- **When to use this pattern:** Max/min problems with adjacent element constraints
- **Key indicator:** "Cannot use adjacent elements" + "maximize/minimize value"
- **Related problems:** House Robber II (circular), Maximum Sum of Non-Adjacent Elements

### Core Tricks

1. **The Decision at Each House**: Two mutually exclusive choices
   ```
   At house i, you can either:
   - Rob it: Get nums[i] + best from i-2 (can't rob i-1)
   - Skip it: Get best from i-1

   dp[i] = max(nums[i] + dp[i-2], dp[i-1])
   ```

2. **Why We Need i-2**: Adjacent constraint
   - If you rob house i, you CAN'T rob house i-1
   - So you get nums[i] + whatever you got from i-2 or earlier
   - The dp[i-2] already contains the best solution up to house i-2

3. **Base Cases Setup**:
   ```typescript
   dp[0] = nums[0]                      // Only one house
   dp[1] = max(nums[0], nums[1])        // Choose better of first two
   ```

4. **Space Optimization Intuition**:
   - To compute dp[i], you only need dp[i-1] and dp[i-2]
   - You never need dp[i-3], dp[i-4], etc.
   - Similar to Fibonacci/Climbing Stairs!
   - Use two variables instead of array

5. **The "Sliding Window" Mental Model**:
   ```
   House:     0    1    2    3    4
   Values:   [2]  [7]  [9]  [3]  [1]

   Step 0:   [2]
   Step 1:   [2]  [7]         ← max(2, 7) = 7
   Step 2:        [7]  [11]   ← max(9+2, 7) = 11
   Step 3:             [11]  [11]   ← max(3+7, 11) = 11
   Step 4:                  [11]  [12]   ← max(1+11, 11) = 12
   ```

   Only need to remember the last 2 values!

### Common Pitfalls

- ⚠️ **Off-by-one errors**: Confusing when to use i-1 vs i-2
- ⚠️ **Base case handling**: Not handling n=1, n=2 before loop
- ⚠️ **Wrong recurrence**: Using `dp[i-1] + dp[i-2]` (that's Fibonacci, not this!)
- ⚠️ **Forgetting the constraint**: Trying to use i-1 when robbing house i
- ⚠️ **Index out of bounds**: Accessing dp[i-2] when i=1

### Edge Cases to Consider

- Single house: `[5]` → Return `5`
- Two houses: `[2, 7]` → Return `7` (better house)
- All same values: `[5, 5, 5, 5]` → Return `10` (rob alternating)
- Descending values: `[10, 5, 2, 1]` → Return `11` (rob 10 and 1)
- Best at edges: `[10, 1, 1, 10]` → Return `20` (rob both ends)

## Understanding the Recurrence

Let's trace `[2, 7, 9, 3, 1]` step by step:

```
dp[0] = 2
  - Only house 0, take it

dp[1] = max(2, 7) = 7
  - House 0 has $2, house 1 has $7
  - Can only rob one, choose $7

dp[2] = max(9 + dp[0], dp[1]) = max(9 + 2, 7) = 11
  - Rob house 2 ($9) + best from 0-1 houses back (dp[0] = $2)
  - OR skip house 2, take best from previous house (dp[1] = $7)
  - $11 > $7, so rob house 2!

dp[3] = max(3 + dp[1], dp[2]) = max(3 + 7, 11) = 11
  - Rob house 3 ($3) + best from 2 houses back (dp[1] = $7) = $10
  - OR skip house 3, take best from previous (dp[2] = $11)
  - $11 > $10, so skip house 3!

dp[4] = max(1 + dp[2], dp[3]) = max(1 + 11, 11) = 12
  - Rob house 4 ($1) + best from 2 houses back (dp[2] = $11) = $12
  - OR skip house 4, take best from previous (dp[3] = $11)
  - $12 > $11, so rob house 4!

Answer: $12 (houses 0, 2, 4 → $2 + $9 + $1)
```

## Why This Problem Is Important

### Decision-Making DP Pattern

This introduces a fundamental DP pattern:
- **State**: Best solution up to position i
- **Decision**: Two choices at each position (with constraints)
- **Recurrence**: Combine previous states based on decision

### Teaches Key Concepts

1. **Constraint Handling**: Can't use adjacent elements
2. **Optimal Substructure**: Best at i depends on best at i-1 and i-2
3. **Space Optimization**: Array → Two variables
4. **Greedy Doesn't Work**: Can't just pick largest values!

### Real-World Applications

- **Scheduling**: Tasks with cooldown periods
- **Resource Allocation**: Items with dependencies
- **Stock Trading**: Cooldown after selling
- **Sequence Selection**: Maximum sum with no adjacent elements

## Related Problems

### Direct Variants
- [House Robber II](https://leetcode.com/problems/house-robber-ii/) - Houses in a circle (first and last are adjacent)
- [House Robber III](https://leetcode.com/problems/house-robber-iii/) - Houses arranged in binary tree
- [Delete and Earn](https://leetcode.com/problems/delete-and-earn/) - Similar pattern, different constraint

### Similar DP Patterns
- [Maximum Sum of Non-Adjacent Elements](https://leetcode.com/problems/maximum-sum-of-non-adjacent-elements/) - Exact same pattern
- [Paint House](https://leetcode.com/problems/paint-house/) - Three choices instead of two
- [Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/) - Similar state machine
- [Decode Ways](https://leetcode.com/problems/decode-ways/) - Look back 1 or 2 positions

### Advanced Applications
- [Coin Change](https://leetcode.com/problems/coin-change/) - Different decision space
- [Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/) - More complex states
- [Word Break](https://leetcode.com/problems/word-break/) - String DP with decisions
